// helper function that gets the degree sequence of a graph
function findDegreeSequence(graph) {
    // initialize an array to track degree sequence for every vertex
    let degreeSequence = [];
    // loop over every row (vertex)
    for (let i = 0; i < graph.length; i++) {
        // variable to track degree for each vertex within loop
        let degree = 0;
        // loop over every column (vertices possibly connected to outer loop vertex)
        for (let j = 0; j < graph[i].length; j++) {
            // if value at column row intersections is 1, there is an edge between vertices, increment degree of current vertex
            if (graph[i][j] == 1) {
                degree++;
            }
        }
        // once we've checked all possible connections for outer loop vertex, push its degree to our degree sequence
        degreeSequence.push(degree);
    }
    // return degree sequence
    return degreeSequence;
}

// helper function to count degree of each vertex, takes degree sequence as argument 
function countDegrees(degreeSequence) {
    // initialize set to hold vertex degrees and their counts (chatGPT assisted)
    let degreeCount = {};

    // loop over each vertex degree
    for (let i = 0; i < degreeSequence.length; i++) {
        // set degree to current vertex degree
        let degree = degreeSequence[i];
        // if there is no vertex of that degree in degree count, add it with a starting value of 1 (chatGPT assisted)
        if (degreeCount[degree] == undefined) {
            degreeCount[degree] = 1;
        }
        // else there has already been at least one vertex of this count, so we will increment the count of vertices at that degree
        else {
            degreeCount[degree]++;
        }
    }
    // return our degree count set
    return degreeCount;
}

// helper function that uses previous functions if the degree sequences of two functions are equal
function areDegreeSequencesEqual(graph1, graph2) {
    // find the degree sequence of both graphs
    let graph1degree = findDegreeSequence(graph1);
    let graph2degree = findDegreeSequence(graph2);

    // if the degree sequence is not the same length, graphs are not isomorphic, return false
    if (graph1degree.length != graph2degree.length) {
        return false;
    }

    // find the degree count of both graphs
    let graph1count = countDegrees(graph1degree);
    let graph2count = countDegrees(graph2degree);

    // If the count of each degree is not the same, graphs are not isomorphic, return false
    for (let degree in graph1count) {
        if (graph1count[degree] != graph2count[degree]) {
            return false;
        }
    }

    // if they survive all previous if statements, degree sequences are equal and they pass this test, return true
    return true;
}

// helper function to generate all permutations of vertices of the graph, taken from my brute force sorting assignment and adjusted to return an array of permutations not a boolean
function permute(array, start) {
    let allPermutations = [];

    function genPermutations(array, start) {
        if (start == array.length) {
            allPermutations.push([...array]);
            return;
        }

        for (let i = start; i < array.length; i++) {
            [array[start], array[i]] = [array[i], array[start]];

            genPermutations(array, start + 1);

            [array[start], array[i]] = [array[i], array[start]];
        }
    }
    
    genPermutations(array, start);

    return allPermutations;
}

function are_isomorphic(graph1, graph2) {
    // Call our degree sequence check function with our two graphs, if that call returns false, return false as graphs are not isomorphic
    if (areDegreeSequencesEqual(graph1, graph2) == false) {
        return false;
    }

    // Generate an initial array of vertices in our graph (chatGPT assisted)
    let vertices = Array.from({ length: graph1.length }, (_, i) => i);
    // call permutation function to get all permutations of our vertices
    let permutations = permute(vertices, 0);

    // loop over every permutation
    for (let i = 0; i < permutations.length; i++) {
        let permutation = permutations[i];
        // initialize a boolean variable to track whether or not we find a permutation that matches the vertices of the two graphs
        let match = true;

        // double nested loop to loop over every connection in graph 1
        for (let j = 0; j < graph1.length; j++) {
            for (let k = 0; k < graph1.length; k++) {
                // check if the current connection in graph 1 is equal to the connection in graph two at the indices generated by our current permutaton, if not, set match to false and break inner loop
                if (graph1[j][k] != graph2[permutation[j]][permutation[k]]) {
                    match = false;
                    break;
                }
            }
            // if match is set to false after leaving inner loop, break outer loop as current permutation is not viable match
            if (!match) break;
        }

        // if match is still set to true after entire permutation has been checked, graphs are isomorphic, return true
        if (match) {
            return true;
        }
    }

    // no match was found, return false
    return false;
}

/*
let graph1 = [
    [0, 1],
    [1, 0]
];

let graph2 = [
    [0, 1],
    [1, 0]
]

console.log(are_isomorphic(graph1, graph2));
*/
